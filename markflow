#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ─── SOCIAL ICON SVGS ───
ICON_GITHUB='<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>'
ICON_TWITTER='<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>'
ICON_DISCORD='<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.317 4.37a19.791 19.791 0 00-4.885-1.515.074.074 0 00-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 00-5.487 0 12.64 12.64 0 00-.617-1.25.077.077 0 00-.079-.037A19.736 19.736 0 003.677 4.37a.07.07 0 00-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 00.031.057 19.9 19.9 0 005.993 3.03.078.078 0 00.084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 00-.041-.106 13.107 13.107 0 01-1.872-.892.077.077 0 01-.008-.128 10.2 10.2 0 00.372-.292.074.074 0 01.077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 01.078.01c.12.098.246.198.373.292a.077.077 0 01-.006.127 12.299 12.299 0 01-1.873.892.077.077 0 00-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 00.084.028 19.839 19.839 0 006.002-3.03.077.077 0 00.032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 00-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/></svg>'
ICON_LINKEDIN='<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>'
ICON_YOUTUBE='<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M23.498 6.186a3.016 3.016 0 00-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 00.502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 002.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 002.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>'
ICON_WEBSITE='<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/></svg>'
ICON_DEFAULT_LOGO='<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>'

# ─── HELPERS ───
die() { echo "error: $*" >&2; exit 1; }

usage() {
  cat <<'USAGE'
markflow — Generate beautiful documentation from Markdown

Usage:
  markflow init                              Create .env with defaults
  markflow build [options]                   Generate index.html
  markflow serve [--port PORT] [--dir DIR]   Local preview server

Build options:
  --output DIR          Output directory (default: ./dist)
  --prebake             Pre-bake content (embed markdown into HTML)
  --source DIR          Local markdown source for pre-baking
  --config FILE         Config file path (default: .env)
  --serve               Start preview server after build
  --port PORT           Server port (default: 3000, used with --serve)

Examples:
  markflow init
  markflow build --output ./public
  markflow build --prebake --source ./docs
  markflow build --prebake --source ./docs --serve
  markflow build --prebake --serve --port 8080
  markflow serve --port 8080

USAGE
  exit 0
}

# ─── FIND TEMPLATE ───
find_template() {
  # Check same directory as script, then ~/.markflow/
  if [[ -f "$SCRIPT_DIR/template.html" ]]; then
    echo "$SCRIPT_DIR/template.html"
  elif [[ -f "$HOME/.markflow/template.html" ]]; then
    echo "$HOME/.markflow/template.html"
  else
    die "template.html not found. Expected at $SCRIPT_DIR/template.html or ~/.markflow/template.html"
  fi
}

# ─── PARSE .ENV ───
parse_env() {
  local file="$1"
  [[ -f "$file" ]] || die "Config file not found: $file"
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and blank lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    # Split on first =
    local key="${line%%=*}"
    local val="${line#*=}"
    # Trim whitespace
    key="$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    val="$(echo "$val" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    # Remove surrounding quotes
    val="${val%\"}"
    val="${val#\"}"
    val="${val%\'}"
    val="${val#\'}"
    # Export
    export "$key=$val" 2>/dev/null || true
  done < "$file"
}

# ─── INIT COMMAND ───
cmd_init() {
  if [[ -f ".env" ]]; then
    echo ".env already exists. Overwrite? (y/N)"
    read -r ans
    [[ "$ans" =~ ^[Yy] ]] || { echo "Aborted."; exit 0; }
  fi
  cat > .env <<'ENVFILE'
# Markflow Configuration
# See: https://github.com/darmie/markflow

# Repository
MARKFLOW_REPO_OWNER=
MARKFLOW_REPO_NAME=
MARKFLOW_REPO_BRANCH=main
MARKFLOW_REPO_ROOT=
MARKFLOW_BRANCH_SWITCHER=true

# Branding
MARKFLOW_BRAND_NAME=
MARKFLOW_BRAND_LOGO=

# Theme Colors
MARKFLOW_ACCENT=#c4956a
MARKFLOW_ACCENT_DIM=#9a7554
MARKFLOW_ACCENT_BRIGHT=#daa87a
MARKFLOW_BG_PRIMARY=#0a0a0c
MARKFLOW_BG_SECONDARY=#111116
MARKFLOW_BG_TERTIARY=#18181f
MARKFLOW_TEXT_PRIMARY=#e8e6e3
MARKFLOW_TEXT_SECONDARY=#9a9aab
MARKFLOW_TEXT_MUTED=#5e5e72
MARKFLOW_BORDER=#2a2a35
MARKFLOW_CODE_BG=#0d0d12

# Social Links (leave blank to hide)
MARKFLOW_SOCIAL_GITHUB=
MARKFLOW_SOCIAL_TWITTER=
MARKFLOW_SOCIAL_DISCORD=
MARKFLOW_SOCIAL_LINKEDIN=
MARKFLOW_SOCIAL_YOUTUBE=
MARKFLOW_SOCIAL_WEBSITE=

# SEO & Open Graph (leave blank to omit)
MARKFLOW_DESCRIPTION=
MARKFLOW_URL=
MARKFLOW_OG_IMAGE=

# Giscus Comments (leave blank to disable)
# Get repo ID and category ID from https://giscus.app
MARKFLOW_GISCUS_REPO=
MARKFLOW_GISCUS_REPO_ID=
MARKFLOW_GISCUS_CATEGORY=General
MARKFLOW_GISCUS_CATEGORY_ID=

# LLM-friendly output (generates llms.txt, llms-full.txt, api.json)
MARKFLOW_LLM_FRIENDLY=true

# GitHub API token for pre-baking (optional)
# GITHUB_TOKEN=
ENVFILE
  echo "Created .env — edit it with your repo details."
}

# ─── FETCH GISCUS IDS ───
# Auto-fetches repo ID and category ID from GitHub GraphQL API
fetch_giscus_ids() {
  local repo="$1"
  local category="$2"
  local token="${GITHUB_TOKEN:-}"

  local auth_args=()
  if [[ -n "$token" ]]; then
    auth_args=(-H "Authorization: bearer ${token}")
  fi

  local query='{"query":"{ repository(owner: \"'${repo%%/*}'\", name: \"'${repo#*/}'\") { id discussionCategories(first: 25) { nodes { id name } } } }"}'

  local response
  response="$(curl -sS "${auth_args[@]}" -H "Content-Type: application/json" -d "$query" https://api.github.com/graphql 2>/dev/null)" || return

  # Extract repo ID
  local repo_id
  repo_id="$(echo "$response" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['data']['repository']['id'])" 2>/dev/null)" || return
  export MARKFLOW_GISCUS_REPO_ID="$repo_id"
  echo "  Fetched repo ID: ${repo_id}" >&2

  # Extract category ID
  local cat_id
  cat_id="$(echo "$response" | python3 -c "
import sys,json
d=json.load(sys.stdin)
target='${category}'
for n in d['data']['repository']['discussionCategories']['nodes']:
    if n['name']==target:
        print(n['id'])
        break
" 2>/dev/null)" || return
  if [[ -n "$cat_id" ]]; then
    export MARKFLOW_GISCUS_CATEGORY_ID="$cat_id"
    echo "  Fetched category ID: ${cat_id}" >&2
  fi
}

# ─── BUILD CONFIG JS ───
build_config_js() {
  local owner="${MARKFLOW_REPO_OWNER:-}"
  local name="${MARKFLOW_REPO_NAME:-}"
  local branch="${MARKFLOW_REPO_BRANCH:-main}"
  local root="${MARKFLOW_REPO_ROOT:-}"
  local branch_switcher="${MARKFLOW_BRANCH_SWITCHER:-false}"
  local giscus_repo="${MARKFLOW_GISCUS_REPO:-}"
  local giscus_repo_id="${MARKFLOW_GISCUS_REPO_ID:-}"
  local giscus_category="${MARKFLOW_GISCUS_CATEGORY:-General}"
  local giscus_category_id="${MARKFLOW_GISCUS_CATEGORY_ID:-}"

  [[ -n "$owner" ]] || die "MARKFLOW_REPO_OWNER is required"
  [[ -n "$name" ]] || die "MARKFLOW_REPO_NAME is required"

  # Auto-fetch giscus IDs if repo is set but IDs are missing
  if [[ -n "$giscus_repo" ]] && [[ -z "$giscus_repo_id" || -z "$giscus_category_id" ]]; then
    echo "Fetching giscus IDs from GitHub..." >&2
    fetch_giscus_ids "$giscus_repo" "$giscus_category"
    giscus_repo_id="${MARKFLOW_GISCUS_REPO_ID:-}"
    giscus_category_id="${MARKFLOW_GISCUS_CATEGORY_ID:-}"
  fi

  cat <<CONFIGJS
{repo:{owner:"${owner}",name:"${name}",branch:"${branch}",root:"${root}"},branchSwitcher:${branch_switcher},giscus:{repo:"${giscus_repo}",repoId:"${giscus_repo_id}",category:"${giscus_category}",categoryId:"${giscus_category_id}"}}
CONFIGJS
}

# ─── BUILD THEME OVERRIDE ───
build_theme_css() {
  local css_vars=""
  [[ -n "${MARKFLOW_ACCENT:-}" ]] && css_vars="${css_vars}--accent:${MARKFLOW_ACCENT};"
  [[ -n "${MARKFLOW_ACCENT_DIM:-}" ]] && css_vars="${css_vars}--accent-dim:${MARKFLOW_ACCENT_DIM};"
  [[ -n "${MARKFLOW_ACCENT_BRIGHT:-}" ]] && css_vars="${css_vars}--accent-bright:${MARKFLOW_ACCENT_BRIGHT};"
  [[ -n "${MARKFLOW_BG_PRIMARY:-}" ]] && css_vars="${css_vars}--bg-primary:${MARKFLOW_BG_PRIMARY};"
  [[ -n "${MARKFLOW_BG_SECONDARY:-}" ]] && css_vars="${css_vars}--bg-secondary:${MARKFLOW_BG_SECONDARY};"
  [[ -n "${MARKFLOW_BG_TERTIARY:-}" ]] && css_vars="${css_vars}--bg-tertiary:${MARKFLOW_BG_TERTIARY};"
  [[ -n "${MARKFLOW_TEXT_PRIMARY:-}" ]] && css_vars="${css_vars}--text-primary:${MARKFLOW_TEXT_PRIMARY};"
  [[ -n "${MARKFLOW_TEXT_SECONDARY:-}" ]] && css_vars="${css_vars}--text-secondary:${MARKFLOW_TEXT_SECONDARY};"
  [[ -n "${MARKFLOW_TEXT_MUTED:-}" ]] && css_vars="${css_vars}--text-muted:${MARKFLOW_TEXT_MUTED};"
  [[ -n "${MARKFLOW_BORDER:-}" ]] && css_vars="${css_vars}--border:${MARKFLOW_BORDER};"
  [[ -n "${MARKFLOW_CODE_BG:-}" ]] && css_vars="${css_vars}--code-bg:${MARKFLOW_CODE_BG};"

  if [[ -n "$css_vars" ]]; then
    echo "<style>:root{${css_vars}}</style>"
  fi
}

# ─── BUILD SOCIAL ICONS ───
build_social_icons() {
  local html=""
  [[ -n "${MARKFLOW_SOCIAL_GITHUB:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_GITHUB}\" target=\"_blank\" rel=\"noopener\" title=\"GitHub\">${ICON_GITHUB}</a>"
  [[ -n "${MARKFLOW_SOCIAL_TWITTER:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_TWITTER}\" target=\"_blank\" rel=\"noopener\" title=\"Twitter\">${ICON_TWITTER}</a>"
  [[ -n "${MARKFLOW_SOCIAL_DISCORD:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_DISCORD}\" target=\"_blank\" rel=\"noopener\" title=\"Discord\">${ICON_DISCORD}</a>"
  [[ -n "${MARKFLOW_SOCIAL_LINKEDIN:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_LINKEDIN}\" target=\"_blank\" rel=\"noopener\" title=\"LinkedIn\">${ICON_LINKEDIN}</a>"
  [[ -n "${MARKFLOW_SOCIAL_YOUTUBE:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_YOUTUBE}\" target=\"_blank\" rel=\"noopener\" title=\"YouTube\">${ICON_YOUTUBE}</a>"
  [[ -n "${MARKFLOW_SOCIAL_WEBSITE:-}" ]] && html="${html}<a href=\"${MARKFLOW_SOCIAL_WEBSITE}\" target=\"_blank\" rel=\"noopener\" title=\"Website\">${ICON_WEBSITE}</a>"
  echo "$html"
}

# ─── BUILD BRAND ───
build_brand_logo() {
  local logo="${MARKFLOW_BRAND_LOGO:-}"
  if [[ -n "$logo" ]]; then
    # If it's a file path, try to read it as inline SVG
    if [[ -f "$logo" ]] && [[ "$logo" == *.svg ]]; then
      cat "$logo"
    else
      # Treat as URL or inline SVG string
      if [[ "$logo" == "<svg"* ]]; then
        echo "$logo"
      else
        echo "<img src=\"${logo}\" alt=\"logo\" style=\"height:20px;\">"
      fi
    fi
  else
    echo "$ICON_DEFAULT_LOGO"
  fi
}

# ─── EXTRACT DESCRIPTION FROM MARKDOWN ───
# Looks for summary.md or index.md, extracts first paragraph as description
extract_description() {
  local source_dir="$1"
  [[ -d "$source_dir" ]] || return

  local desc_file=""
  # Priority: summary.md > index.md > first .md file alphabetically
  for candidate in "summary.md" "SUMMARY.md" "index.md" "INDEX.md"; do
    if [[ -f "${source_dir}/${candidate}" ]]; then
      desc_file="${source_dir}/${candidate}"
      break
    fi
  done
  # Fallback to first .md file
  if [[ -z "$desc_file" ]]; then
    desc_file="$(find "$source_dir" -maxdepth 1 -type f -name "*.md" | sort | head -1)"
  fi
  [[ -z "$desc_file" ]] && return

  # Extract first paragraph: skip headings, blank lines, then grab text until next blank line
  local para=""
  local in_para=false
  while IFS= read -r line; do
    # Skip headings and blank lines before paragraph
    if [[ "$in_para" == false ]]; then
      [[ "$line" =~ ^#+ ]] && continue
      [[ "$line" =~ ^[[:space:]]*$ ]] && continue
      in_para=true
    fi
    # Stop at blank line after paragraph starts
    if [[ "$in_para" == true ]] && [[ "$line" =~ ^[[:space:]]*$ ]]; then
      break
    fi
    [[ -n "$para" ]] && para="${para} "
    para="${para}${line}"
  done < "$desc_file"

  # Strip markdown formatting: bold, italic, code, links
  para="$(echo "$para" | sed 's/\*\*\([^*]*\)\*\*/\1/g; s/\*\([^*]*\)\*/\1/g; s/`\([^`]*\)`/\1/g; s/\[\([^]]*\)\]([^)]*)/\1/g')"
  # Truncate to 160 chars for meta description
  if [[ ${#para} -gt 160 ]]; then
    para="${para:0:157}..."
  fi
  echo "$para"
}

# ─── BUILD SEO META ───
build_seo_meta() {
  local title="${MARKFLOW_BRAND_NAME:-${MARKFLOW_REPO_NAME:-Markflow}}"
  local desc="${MARKFLOW_DESCRIPTION:-}"
  local url="${MARKFLOW_URL:-}"
  local image="${MARKFLOW_OG_IMAGE:-}"
  local meta=""

  # Basic meta
  [[ -n "$desc" ]] && meta="${meta}<meta name=\"description\" content=\"${desc}\">"

  # Open Graph
  meta="${meta}<meta property=\"og:type\" content=\"website\">"
  meta="${meta}<meta property=\"og:title\" content=\"${title}\">"
  [[ -n "$desc" ]] && meta="${meta}<meta property=\"og:description\" content=\"${desc}\">"
  [[ -n "$url" ]] && meta="${meta}<meta property=\"og:url\" content=\"${url}\">"
  [[ -n "$image" ]] && meta="${meta}<meta property=\"og:image\" content=\"${image}\">"

  # Twitter Card
  meta="${meta}<meta name=\"twitter:card\" content=\"summary_large_image\">"
  meta="${meta}<meta name=\"twitter:title\" content=\"${title}\">"
  [[ -n "$desc" ]] && meta="${meta}<meta name=\"twitter:description\" content=\"${desc}\">"
  [[ -n "$image" ]] && meta="${meta}<meta name=\"twitter:image\" content=\"${image}\">"

  echo "$meta"
}

# ─── PRE-BAKE: LOCAL SOURCE ───
prebake_local() {
  local source_dir="$1"
  [[ -d "$source_dir" ]] || die "Source directory not found: $source_dir"

  local js="{"
  local first=true

  while IFS= read -r -d '' file; do
    local relpath="${file#"$source_dir"/}"
    local encoded
    encoded="$(base64 < "$file" | tr -d '\n')"
    if [[ "$first" == true ]]; then
      first=false
    else
      js="${js},"
    fi
    js="${js}\"${relpath}\":\"${encoded}\""
  done < <(find "$source_dir" -type f \( -name "*.md" -o -name "*.markdown" -o -name "*.mdx" \) -print0 | sort -z)

  js="${js}}"
  echo "{files:${js}}"
}

# ─── PRE-BAKE: GITHUB API ───
prebake_github() {
  local owner="${MARKFLOW_REPO_OWNER:-}"
  local repo="${MARKFLOW_REPO_NAME:-}"
  local branch="${MARKFLOW_REPO_BRANCH:-main}"
  local root="${MARKFLOW_REPO_ROOT:-}"
  local token="${GITHUB_TOKEN:-}"

  [[ -n "$owner" ]] || die "MARKFLOW_REPO_OWNER is required for GitHub pre-baking"
  [[ -n "$repo" ]] || die "MARKFLOW_REPO_NAME is required for GitHub pre-baking"

  local auth_header=""
  if [[ -n "$token" ]]; then
    auth_header="-H \"Authorization: token ${token}\""
  fi

  echo "Fetching tree from GitHub..." >&2
  local tree_url="https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1"
  local tree_json
  if [[ -n "$token" ]]; then
    tree_json="$(curl -sS -H "Authorization: token ${token}" "$tree_url")"
  else
    tree_json="$(curl -sS "$tree_url")"
  fi

  # Extract markdown file paths using grep/sed
  local paths
  paths="$(echo "$tree_json" | grep '"path"' | sed 's/.*"path"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | grep -E '\.(md|markdown|mdx)$')"

  if [[ -n "$root" ]]; then
    paths="$(echo "$paths" | grep "^${root}/" | sed "s|^${root}/||")"
  fi

  if [[ -z "$paths" ]]; then
    die "No markdown files found in the repository"
  fi

  local js="{"
  local first=true
  local count=0

  while IFS= read -r filepath; do
    [[ -z "$filepath" ]] && continue
    local full_path="$filepath"
    [[ -n "$root" ]] && full_path="${root}/${filepath}"
    local raw_url="https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${full_path}"

    echo "  Fetching: ${filepath}" >&2
    local content
    if [[ -n "$token" ]]; then
      content="$(curl -sS -H "Authorization: token ${token}" "$raw_url")"
    else
      content="$(curl -sS "$raw_url")"
    fi
    local encoded
    encoded="$(echo "$content" | base64 | tr -d '\n')"

    if [[ "$first" == true ]]; then
      first=false
    else
      js="${js},"
    fi
    js="${js}\"${filepath}\":\"${encoded}\""
    count=$((count + 1))
  done <<< "$paths"

  js="${js}}"
  echo "Pre-baked ${count} files." >&2
  echo "{files:${js}}"
}

# ─── GENERATE LLMS.TXT ───
generate_llms_txt() {
  local source_dir="$1"
  local output_dir="$2"
  local brand="${MARKFLOW_BRAND_NAME:-${MARKFLOW_REPO_NAME:-Markflow}}"
  local desc="${MARKFLOW_DESCRIPTION:-}"
  local url="${MARKFLOW_URL:-}"

  local llms_txt=""
  local llms_full=""

  # Header
  llms_txt="# ${brand}"$'\n\n'
  llms_full="# ${brand}"$'\n\n'

  if [[ -n "$desc" ]]; then
    llms_txt="${llms_txt}> ${desc}"$'\n\n'
    llms_full="${llms_full}> ${desc}"$'\n\n'
  fi

  llms_txt="${llms_txt}## Docs"$'\n\n'

  local first_full=true

  while IFS= read -r -d '' file; do
    local relpath="${file#"$source_dir"/}"

    # Skip summary.md / index.md (not real doc pages)
    local basename
    basename="$(basename "$relpath")"
    local lower_base
    lower_base="$(echo "$basename" | tr '[:upper:]' '[:lower:]')"
    [[ "$lower_base" == "summary.md" || "$lower_base" == "index.md" || "$lower_base" == "readme.md" ]] && continue

    local content
    content="$(cat "$file")"

    # Extract H1 title
    local title
    title="$(echo "$content" | grep -m1 '^# ' | sed 's/^# //')"
    [[ -z "$title" ]] && title="$(echo "$relpath" | sed 's/\.[^.]*$//; s/[-_]/ /g; s/[0-9]*-//')"

    # Extract first paragraph for summary
    local summary=""
    local in_para=false
    while IFS= read -r line; do
      if [[ "$in_para" == false ]]; then
        [[ "$line" =~ ^#+ ]] && continue
        [[ "$line" =~ ^[[:space:]]*$ ]] && continue
        in_para=true
      fi
      if [[ "$in_para" == true ]] && [[ "$line" =~ ^[[:space:]]*$ ]]; then
        break
      fi
      [[ -n "$summary" ]] && summary="${summary} "
      summary="${summary}${line}"
    done <<< "$content"
    # Strip markdown
    summary="$(echo "$summary" | sed 's/\*\*\([^*]*\)\*\*/\1/g; s/\*\([^*]*\)\*/\1/g; s/`\([^`]*\)`/\1/g; s/\[\([^]]*\)\]([^)]*)/\1/g')"
    [[ ${#summary} -gt 120 ]] && summary="${summary:0:117}..."

    # llms.txt: page link + summary
    if [[ -n "$url" ]]; then
      llms_txt="${llms_txt}- [${title}](${url}#${relpath}): ${summary}"$'\n'
    else
      llms_txt="${llms_txt}- [${title}](#${relpath}): ${summary}"$'\n'
    fi

    # llms-full.txt: full content
    if [[ "$first_full" == true ]]; then
      first_full=false
    else
      llms_full="${llms_full}"$'\n---\n\n'
    fi
    llms_full="${llms_full}${content}"$'\n'

  done < <(find "$source_dir" -type f \( -name "*.md" -o -name "*.markdown" -o -name "*.mdx" \) -print0 | sort -z)

  echo "$llms_txt" > "${output_dir}/llms.txt"
  echo "$llms_full" > "${output_dir}/llms-full.txt"
  echo "Generated: llms.txt, llms-full.txt" >&2
}

# ─── GENERATE API.JSON ───
generate_api_json() {
  local source_dir="$1"
  local output_dir="$2"
  local brand="${MARKFLOW_BRAND_NAME:-${MARKFLOW_REPO_NAME:-Markflow}}"
  local desc="${MARKFLOW_DESCRIPTION:-}"
  local url="${MARKFLOW_URL:-}"

  # Collect file paths and contents, then use Python to build JSON safely
  local file_list=""
  while IFS= read -r -d '' file; do
    local relpath="${file#"$source_dir"/}"
    local basename
    basename="$(basename "$relpath")"
    local lower_base
    lower_base="$(echo "$basename" | tr '[:upper:]' '[:lower:]')"
    [[ "$lower_base" == "summary.md" || "$lower_base" == "index.md" || "$lower_base" == "readme.md" ]] && continue
    [[ -n "$file_list" ]] && file_list="${file_list}|"
    file_list="${file_list}${file}"
  done < <(find "$source_dir" -type f \( -name "*.md" -o -name "*.markdown" -o -name "*.mdx" \) -print0 | sort -z)

  python3 -c "
import json, re, os, sys

brand = '''${brand}'''
desc = '''${desc}'''
url = '''${url}'''
source_dir = '''${source_dir}'''
file_list = '''${file_list}'''

pages = []
for fpath in file_list.split('|'):
    if not fpath:
        continue
    relpath = os.path.relpath(fpath, source_dir)
    with open(fpath, 'r') as f:
        content = f.read()

    # Extract H1 title
    title_match = re.search(r'^# (.+)$', content, re.MULTILINE)
    title = title_match.group(1) if title_match else relpath.rsplit('.', 1)[0].replace('-', ' ').replace('_', ' ').strip()

    # Extract H2 sections
    sections = re.findall(r'^## (.+)$', content, re.MULTILINE)

    pages.append({
        'path': relpath,
        'title': title,
        'sections': sections,
        'content': content
    })

result = {
    'name': brand,
    'description': desc,
    'url': url,
    'pages': pages
}

with open(os.path.join('''${output_dir}''', 'api.json'), 'w') as f:
    json.dump(result, f, indent=2, ensure_ascii=False)
" 2>&1

  echo "Generated: api.json" >&2
}

# ─── BUILD COMMAND ───
cmd_build() {
  local output_dir="./dist"
  local prebake=false
  local source_dir=""
  local config_file=".env"
  local serve_after=false
  local serve_port=3000

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --output)  output_dir="$2"; shift 2 ;;
      --prebake) prebake=true; shift ;;
      --source)  source_dir="$2"; shift 2 ;;
      --config)  config_file="$2"; shift 2 ;;
      --serve)   serve_after=true; shift ;;
      --port)    serve_port="$2"; shift 2 ;;
      *) die "Unknown build option: $1" ;;
    esac
  done

  # Parse config
  parse_env "$config_file"

  # Find template
  local template
  template="$(find_template)"

  # Build replacements
  local config_js
  config_js="$(build_config_js)"

  local theme_css
  theme_css="$(build_theme_css)"

  local social_html
  social_html="$(build_social_icons)"

  local brand_logo
  brand_logo="$(build_brand_logo)"

  local brand_name="${MARKFLOW_BRAND_NAME:-${MARKFLOW_REPO_NAME:-Markflow}}"

  local page_title="${MARKFLOW_BRAND_NAME:-${MARKFLOW_REPO_NAME:-Markflow}}"

  # Auto-extract description from summary.md/index.md if not set
  if [[ -z "${MARKFLOW_DESCRIPTION:-}" ]] && [[ -n "$source_dir" ]]; then
    local auto_desc
    auto_desc="$(extract_description "$source_dir")"
    if [[ -n "$auto_desc" ]]; then
      export MARKFLOW_DESCRIPTION="$auto_desc"
    fi
  fi

  local seo_meta
  seo_meta="$(build_seo_meta)"

  # Pre-bake content if requested
  local content_js="null"
  if [[ "$prebake" == true ]]; then
    if [[ -n "$source_dir" ]]; then
      content_js="$(prebake_local "$source_dir")"
    else
      content_js="$(prebake_github)"
    fi
  fi

  # Create output directory
  mkdir -p "$output_dir"

  # Generate LLM-friendly files
  local llm_friendly="${MARKFLOW_LLM_FRIENDLY:-}"
  if [[ -z "$llm_friendly" ]] && [[ "$prebake" == true ]] && [[ -n "$source_dir" ]]; then
    llm_friendly="true"
  fi
  if [[ "$llm_friendly" == "true" ]] && [[ -n "$source_dir" ]]; then
    generate_llms_txt "$source_dir" "$output_dir"
    generate_api_json "$source_dir" "$output_dir"
  fi

  # Read template and perform replacements
  local html
  html="$(cat "$template")"

  # Replace placeholders using sed with different delimiters to avoid conflicts
  # We use a temp file approach to handle large replacements safely

  local tmpfile
  tmpfile="$(mktemp)"
  echo "$html" > "$tmpfile"

  # Page title
  sed -i.bak "s|<!-- __PAGE_TITLE__ -->|${page_title}|g" "$tmpfile"

  # SEO meta tags
  if [[ -n "$seo_meta" ]]; then
    local escaped_seo
    escaped_seo="$(echo "$seo_meta" | sed 's/[&/\]/\\&/g' | tr -d '\n')"
    sed -i.bak "s|<!-- __SEO_META__ -->|${escaped_seo}|g" "$tmpfile"
  else
    sed -i.bak "s|<!-- __SEO_META__ -->||g" "$tmpfile"
  fi

  # Theme override (insert before the default <style> block)
  if [[ -n "$theme_css" ]]; then
    # Escape for sed
    local escaped_css
    escaped_css="$(echo "$theme_css" | sed 's/[&/\]/\\&/g')"
    sed -i.bak "s|<!-- __THEME_OVERRIDE__ -->|${escaped_css}|g" "$tmpfile"
  else
    sed -i.bak "s|<!-- __THEME_OVERRIDE__ -->||g" "$tmpfile"
  fi

  # Brand logo
  local escaped_logo
  escaped_logo="$(echo "$brand_logo" | sed 's/[&/\]/\\&/g' | tr -d '\n')"
  sed -i.bak "s|<!-- __BRAND_LOGO__ -->|${escaped_logo}|g" "$tmpfile"

  # Brand name
  sed -i.bak "s|<!-- __BRAND_NAME__ -->|${brand_name}|g" "$tmpfile"

  # Social icons
  if [[ -n "$social_html" ]]; then
    local escaped_social
    escaped_social="$(echo "$social_html" | sed 's/[&/\]/\\&/g' | tr -d '\n')"
    sed -i.bak "s|<!-- __SOCIAL_ICONS__ -->|${escaped_social}|g" "$tmpfile"
  else
    sed -i.bak "s|<!-- __SOCIAL_ICONS__ -->||g" "$tmpfile"
  fi

  # Config JS — use a Python one-liner for safe replacement (avoids sed escaping nightmare)
  python3 -c "
import sys
with open('$tmpfile', 'r') as f:
    content = f.read()
config = '''$config_js'''
content = content.replace('/* __MARKFLOW_CONFIG_PLACEHOLDER__ */ null', config.strip())
prebake = '''$content_js'''
content = content.replace('/* __MARKFLOW_CONTENT_PLACEHOLDER__ */ null', prebake.strip())
with open('$tmpfile', 'w') as f:
    f.write(content)
"

  # Copy to output
  cp "$tmpfile" "${output_dir}/index.html"
  rm -f "$tmpfile" "${tmpfile}.bak"

  echo "Built: ${output_dir}/index.html"

  if [[ "$serve_after" == true ]]; then
    cmd_serve --port "$serve_port" --dir "$output_dir"
  fi
}

# ─── SERVE COMMAND ───
cmd_serve() {
  local port=3000
  local dir="./dist"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port) port="$2"; shift 2 ;;
      --dir)  dir="$2"; shift 2 ;;
      *) die "Unknown serve option: $1" ;;
    esac
  done

  [[ -f "${dir}/index.html" ]] || die "No index.html found in ${dir}. Run 'markflow build' first."

  echo "Serving ${dir} on http://localhost:${port}"
  if command -v python3 &>/dev/null; then
    cd "$dir" && python3 -m http.server "$port"
  elif command -v npx &>/dev/null; then
    npx -y serve "$dir" -l "$port"
  else
    die "Neither python3 nor npx found. Install one to use 'markflow serve'."
  fi
}

# ─── MAIN ───
[[ $# -eq 0 ]] && usage

case "$1" in
  init)    cmd_init ;;
  build)   shift; cmd_build "$@" ;;
  serve)   shift; cmd_serve "$@" ;;
  --version|-v) echo "markflow $VERSION" ;;
  --help|-h)    usage ;;
  *) die "Unknown command: $1. Run 'markflow --help' for usage." ;;
esac
